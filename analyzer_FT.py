#!/usr/bin/env python
from __future__ import division

__author__ = 'vladimir'

'''
This script will be used to analyze the data generated by the QUEST simulation

'''
import common.get_file_list
import common.fequals
import common.divide_into_classes
import common.merge
import common.choices
import argparse
from pylab import *
import os

execfile(os.path.join(os.getcwd(), "common", "plot_properties.py"))

parser = argparse.ArgumentParser()
parser.add_argument('-t', type=float, default=1, help="hopping strength t")
parser.add_argument('-rho', type=float, help='electronic density')
parser.add_argument('-u', type=float, help="u term")
parser.add_argument('-beta', type=float, help="inverse temperature")

parser.add_argument('-m', type=str, help="Name of the model")
parser.add_argument('-y_variable', type=str, help="variable along y axis")
parser.add_argument('-to_screen', default=False, type=bool, help='Should we print results on the screen or not.')

parser.add_argument('-legend', type=str, help='legend position. Possible values: lr, ur, ll, ul')

args = parser.parse_args(sys.argv[1:])

modelName = args.m

path = os.path.join('..', '..', 'results', modelName)

dataList = common.get_file_list.get_filelist(modelName, path)

#Clean up datafiles that are for sure bad. No moves were performed.
dataList = [item for item in dataList if
            ((item.get_global_sites() > 0 and item.get_global_accept > 0) or item.get_global_sites() == 0)]

#Not using files, that they have mu = 0 and 0 global moves, when u is not zero.
# dataList = [item for item in dataList if
#             ((
#              item.get_u() != 0 and item.get_mu_up() == 0 and item.get_global_sites() > 0) or item.get_u() == 0 or item.get_mu_up() != 0)]

#We know from symmetry that at mu = 0, rho = 1, I will assume that 0.97 - 1.03 is ok
if args.rho == 1:
  dataList = [item for item in dataList if (abs(item.get_rho()[0] - 1) <= 0.03)]

# We need to remove datapoints if s-wave errorbars > 20%
dataList = [item for item in dataList if (abs(item.get_s_wave()[1] / item.get_s_wave()[0]) < 0.2)]

dataList = [item for item in dataList if (common.fequals.equals(item.get_t_up(), args.t)
                                          and common.fequals.equals(item.get_u(), args.u)
                                          and common.fequals.equals(item.get_beta(), args.beta))]

dataList = [item for item in dataList if abs(item.get_rho()[0] - args.rho) < 0.03]

#divide into classes, corresponding to different number of sites
into_nSites_dict = common.divide_into_classes.divide_into_classes(dataList, parameter='nSites')

#We choose what lattice sizes are we interested in
nSites_list = common.choices.list_choice(into_nSites_dict.keys())

nSites = nSites_list[0] #Number of sites we are working with

dataList = [item for item in dataList if (item.get_nSites() == nSites)]

t_result = []
for item in dataList:
  if args.y_variable == '00':
    t_result += [item.get_FT_pairing_00()]
  elif args.y_variable == '10':
    t_result += [item.get_FT_pairing_10()]
  elif args.y_variable == '11':
    t_result += [item.get_FT_pairing_11()]
  elif args.y_variable == '21':
    t_result += [item.get_FT_pairing_21()]

result = t_result[0]

for i in range(1, len(t_result)):
  result += t_result[i]

x, y = dataList[0].get_kx_points(), dataList[0].get_ky_points()

print 'x = ', x
print 'y = ', y
print 'result = ', result.tolist()

imshow(result, extent=(min(x), max(x), max(y), min(y)))
colorbar()
show()

