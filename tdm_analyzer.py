#!/usr/bin/env python
from __future__ import division

__author__ = 'vladimir'

'''
This script will be used to analyze the data generated by the QUEST simulation
In particular it will analyze time dependent measurements.

x_variables:
  u - fixed mu, beta
  mu - fixed u, beta
  beta - fixed u, mu
  T - fixed u, mu
  x - fixed u, mu, beta
  1L - plot versus 1 / L. fixed u, mu, beta
  rho - plot versus rho. fixed u, beta
  num_sites - plot versus number of sites. fixed rho, u, beta

y_variables:
  ld_xx - current current correlation function.
  energy - total energy
  energy_hop - hopping energy
  m2 - square of the magnetisation
  01 - density-density correlation between 0 and 1 orbital within unit cell
  11 - density-density correlation between 0 and 1 orbital within unit cell
  m0_squared - square of the magnetisation on the 0 orbital
  m1_squares - square of the magnetisation on the 1 orbital
  C - specific heat
  s-wave_rescaled - L^(-7/4) * Ps
  sign_up_down - sign_up times sign_down
'''
import common.get_file_list
import common.fequals
import common.divide_into_classes
import common.merge
import common.choices
from pylab import *
import argparse
import os
import time

start_time = time.time()

execfile(os.path.join(os.getcwd(), "common", "plot_properties.py"))

parser = argparse.ArgumentParser()
parser.add_argument('-t', type=float, default=1, help="hopping strength t")
parser.add_argument('-u', type=float, help="u term")
parser.add_argument('-beta', type=float, help="inverse temperature")

parser.add_argument('-m', type=str, help="Name of the model")

parser.add_argument('-y_variable', type=str, help="""variable along y axis can be
ld_xx_L -
ld_xx_T -
ld_xx_w -
""")

parser.add_argument('-to_screen', default=False, type=bool, help='Should we print results on the screen or not.')

parser.add_argument('-filter', type=bool, default=False, help='Do we filter the data or not. Default True')
parser.add_argument('-vline', type=float, help='Adds vertical line to the plot at a given position')
parser.add_argument('-hline', type=float, help='Adds horizontal line to the plot at a given position')

args = parser.parse_args(sys.argv[1:])
modelName = args.m

allowed_y_variables = ['ld_xx_L',
                       'ld_xx_T',
                       'ld_xx_w']

if args.y_variable not in allowed_y_variables:
  print 'unknown y_variable! ', args.y_variable
  print 'should be one of: ', allowed_y_variables
  sys.exit(0)

execfile('settings.py')

path = os.path.join(folder_with_different_models, modelName)

if args.m == 'chain':
  dimension = 1
else:
  dimension = 2

dataList = common.get_file_list.get_filelist(modelName, path, dimension=dimension)

# Clean up datafiles that are for sure bad. No moves were performed.
dataList = (item for item in dataList if
            ((item.get_global_sites() > 0 and item.get_global_accept > 0) or item.get_global_sites() == 0))

# Clean up datafiles that are for sure bad. Electron density rho is bounded by 0 and 2.
dataList = (item for item in dataList if (0 <= item.get_rho()[0] <= 2))



if args.filter:
  # We need to remove datapoints if s-wave errorbars > 20%
  dataList = (item for item in dataList if (abs(item.get_s_wave()[1] / item.get_s_wave()[0]) < 0.2))

# Filter t
dataList = (item for item in dataList if (common.fequals.equals(item.get_t_up()[0], args.t)))
#Filter t'
if 'anisotropic' in args.m:
  dataList_temp = []
  for item in dataList:
    if len(item.get_t_up()) == 1:
      assert args.t1 == args.t
      dataList_temp += [item]
  dataList = dataList_temp

title(r"{modelname}, $U = {u}$, $\beta = {beta}$, $t={t}$".format(beta=args.beta, u=args.u, modelname=args.m,
                                                                       t=args.t), fontsize=30)

dataList = (item for item in dataList if (common.fequals.equals(item.get_beta(), args.beta)
                                          and common.fequals.equals(item.get_u(), args.u)))


into_nSites_dict = common.divide_into_classes.divide_into_classes(dataList, parameter='shape')

print 'waste of time = ', time.time() - start_time

#We choose what lattice sizes are we interested in
shape_list = common.choices.list_choice(into_nSites_dict.keys())

for shape in shape_list:
  splitted = common.divide_into_classes.divide_into_classes(into_nSites_dict[shape], parameter='mu')

  for key, value in splitted.items():
    for item in value:
      print
      print 'N = ', item.get_nSites()
      print 'beta = ', item.get_beta()
      print 'mu = ', key
      print 'rho = ', item.get_rho()
      print 'kx = ', item.get_kx()
      if args.y_variable == 'ld_xx_L':
        print 'ld_xx_L = ', item.get_ld_L()
      elif args.y_variable == 'ld_xx_T':
        print 'ld_xx_T = ', item.get_ld_T()
      elif args.y_variable == 'ld_xx_w':
        print 'ld_xx_w = ', item.get_ld_w()

